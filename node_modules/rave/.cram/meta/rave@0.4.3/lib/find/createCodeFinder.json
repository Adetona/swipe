{"absId":"rave@0.4.3/lib/find/createCodeFinder","pluginId":"curl/loader/cjsm11","resourceId":"rave@0.4.3/lib/find/createCodeFinder","loader":true,"source":"define('rave@0.4.3/lib/find/createCodeFinder',['require','exports','module'],function(require,exports,module,define){/** @license MIT License (c) copyright 2014 original authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\nmodule.exports = createCodeFinder;\n\n// Export private functions for testing\ncreateCodeFinder.composeRx = composeRx;\ncreateCodeFinder.skipTo = skipTo;\n\n// Look for code transitions.\nvar defaultTransitionsRx = composeRx(\n\t// Detect strings, blank strings, double escapes, and comments.\n\t/(''?|\"\"?|\\\\\\\\|\\/\\/|\\/\\*)/,\n\t// Detect RegExps by excluding division sign and comments\n\t/(?:[\\-+*\\/=\\,%&|^!(;\\{\\[<>]\\s*)(\\/)(?!\\/|\\*)/,\n\t'g'\n);\n\n// RegExps to find end of strings, comments, RegExps in code\n// We can't detect blank strings easily, so we handle those specifically.\nvar defaultSkippers = {\n\t\"''\": false,\n\t'\"\"': false,\n\t'\\\\\\\\': false,\n\t\"'\": /[^\\\\]'/g,\n\t'\"': /[^\\\\]\"/g,\n\t'//': /\\n|$/g,\n\t'/*': /\\*\\//g,\n\t'/': /[^\\\\]\\//g\n};\n\n/**\n * Creates a function that will call a callback function with a set of matches\n * for each occurrence of a pattern match for a given RegExp.  Only true\n * JavaScript is searched.  Comments, strings, and RegExps are skipped.\n * The onMatch callback is called with a single parameter: an array containing\n * the result of calling the RegExp's exec() method.  If onMatch returns a\n * very large number, the pattern matching stops.\n * @param {RegExp} codeRx is a RegExp for the code pattern to find.\n * @param {RegExp} [codeTransitionsRx] is a RegExp to detect transitions into\n *   comments, strings, RegExps, etc.  If omitted, the default RegExp is suited\n *   to JavaScript code.\n * @param {function(matches:Array):number} [skip] is a function that returns\n *   a new position to resume searching the source code.\n * @returns {function(source:string, onMatch:function):string}\n */\nfunction createCodeFinder (codeRx, codeTransitionsRx, skip) {\n\tvar flags, comboRx;\n\n\tif (!codeTransitionsRx) codeTransitionsRx = defaultTransitionsRx;\n\tif (!skip) skip = skipNonCode;\n\n\tflags = 'g';\n\tif (codeRx.multiline) flags += 'm';\n\tif (codeRx.ignoreCase) flags += 'i';\n\n\tcomboRx = composeRx(codeRx, codeTransitionsRx, flags);\n\n\treturn function (source, onMatch) {\n\t\tvar matches, index;\n\n\t\tcomboRx.lastIndex = 0; // reset\n\n\t\twhile (matches = comboRx.exec(source)) {\n\n\t\t\tindex = skip(matches);\n\n\t\t\tif (index < 0) {\n\t\t\t\t// call onMatch and let it optionally skip forward\n\t\t\t\tindex = onMatch(matches);\n\t\t\t}\n\n\t\t\tif (index >= 0) {\n\t\t\t\tcomboRx.lastIndex = index;\n\t\t\t}\n\n\t\t}\n\n\t\treturn source;\n\t};\n}\n\nfunction skipNonCode (matches) {\n\tvar rx, trans, index;\n\t// pop off matches for regexp and other transitions\n\trx = matches.pop();\n\ttrans = matches.pop() || rx;\n\tif (!trans) return -1;\n\tif (defaultSkippers[trans]) {\n\t\tindex = matches.index + matches[0].length;\n\t\treturn skipTo(matches.input, defaultSkippers[trans], index);\n\t}\n}\n\nfunction skipTo (source, rx, index) {\n\trx.lastIndex = index;\n\n\tif (!rx.test(source)) {\n\t\tthrow new Error(\n\t\t\t'Unterminated comment, string, or RegExp at '\n\t\t\t+ index + ' near ' + source.slice(index - 50, 100)\n\t\t);\n\t}\n\n\treturn rx.lastIndex;\n}\n\nfunction composeRx (rx1, rx2, flags) {\n\treturn new RegExp(rx1.source + '|' + rx2.source, flags);\n}\n\n});\n\n","modules":[{"pos":0,"count":116,"id":"rave@0.4.3/lib/find/createCodeFinder","depList":["require","exports","module"],"factory":true,"argList":["require","exports","module","define"]}],"compileTime":"2014-11-17T20:58:47.334Z"}