{"absId":"rave@0.4.3/lib/crawl/common","pluginId":"curl/loader/cjsm11","resourceId":"rave@0.4.3/lib/crawl/common","loader":true,"source":"define('rave@0.4.3/lib/crawl/common',['require','exports','module'],function(require,exports,module,define){/** @license MIT License (c) copyright 2014 original authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n// TODO: don't load metadata for packages that have already been crawled\n\n// main exports\n\nexports.crawl = crawl;\nexports.load = typeof require.async !== 'undefined'\n\t? load\n\t: nativeLoad;\n\n// exports for testing\n\nexports.childIterator = childIterator;\nexports.store = store;\nexports.collectMetadata = collectMetadata;\nexports.collectOverrides = collectOverrides;\nexports.applyOverrides = applyOverrides;\nexports.start = start;\nexports.proceed = proceed;\nexports.end = end;\n\nfunction crawl (context) {\n\tvar load = start(context.load);\n\treturn load(context, context.fileUrl)\n\t\t.then(proceed(applyOverrides))\n\t\t.then(proceed(collectOverrides))\n\t\t.then(proceed(store('metadata')))\n\t\t.then(proceed(context.getChildrenNames))\n\t\t.then(proceed(childIterator))\n\t\t.then(proceed(store('children')))\n\t\t.then(proceed(context.convert))\n\t\t// TODO: start collecting in the context, context.collect?\n\t\t.then(proceed(collectMetadata))\n\t\t.then(end);\n}\n\nfunction load (context, fileUrl) {\n\treturn require.async(fileUrl);\n}\n\nfunction nativeLoad (context, fileUrl) {\n\treturn Promise.resolve(require(fileUrl));\n}\n\nfunction childIterator (context, names) {\n\tvar childCrawlers = names.map(function (name) {\n\t\treturn context.childCrawler(context, name);\n\t});\n\treturn Promise.all(childCrawlers);\n}\n\nfunction store (key) {\n\treturn function (context, value) {\n\t\tcontext[key] = value;\n\t\treturn context;\n\t};\n}\n\nfunction collectMetadata (context, data) {\n\tcontext.all.push(data);\n\treturn data;\n}\n\nfunction collectOverrides (context, data) {\n\tvar key, overrides, missing;\n\tif (data && data.rave) {\n\t\toverrides = data.rave.overrides;\n\t\tfor (key in overrides) {\n\t\t\tcontext.overrides[key] = overrides[key];\n\t\t}\n\t\tmissing = data.rave.missing;\n\t\tfor (key in missing) {\n\t\t\tcontext.missing[key] = missing[key];\n\t\t}\n\t}\n\treturn data;\n}\n\nfunction applyOverrides (context, data) {\n\tif (data) {\n\t\t_applyOverrides(false, context.overrides, data);\n\t\t_applyOverrides(true, context.missing, data);\n\t}\n\treturn data;\n}\n\nfunction _applyOverrides (ifMissing, source, data) {\n\tvar overrides, key;\n\tif (data.name in source) {\n\t\toverrides = source[data.name];\n\t\tfor (key in overrides) {\n\t\t\tif (!ifMissing || !(key in data)) {\n\t\t\t\tdata[key] = overrides[key];\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction start (func) {\n\treturn function (state, value) {\n\t\treturn resolveStateAndValue(func, state, value);\n\t}\n}\n\nfunction proceed (func) {\n\treturn function (stateAndValue) {\n\t\tvar state = stateAndValue[0], value = stateAndValue[1];\n\t\treturn resolveStateAndValue(func, state, value);\n\t};\n}\n\nfunction end (stateAndValue) {\n\treturn stateAndValue[1];\n}\n\nfunction resolveStateAndValue (func, state, value) {\n\treturn Promise.resolve(func.call(this, state, value))\n\t\t.then(function (nextValue) {\n\t\t\treturn [state, nextValue];\n\t\t});\n}\n\n});\n\n","modules":[{"pos":0,"count":107,"id":"rave@0.4.3/lib/crawl/common","depList":["require","exports","module"],"factory":true,"argList":["require","exports","module","define"]}],"compileTime":"2014-11-17T20:58:47.275Z"}